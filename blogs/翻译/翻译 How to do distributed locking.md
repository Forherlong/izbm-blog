写在前面：

我不是英语高手，也不是英语专业出身，偶尔翻译一些英文文章纯属业余爱好（上不了台面，更不敢提"信、达、雅"），对我而言更重要的是文章本身内容的学习和总结。共勉！^_^

如果有人给我提出错误，我没有及时更正别在意哦~



这篇文章是译自 Martin Kleppmann 博客的 《How to do distributed locking》 一文，原文链接：https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

# 如何去做分布式锁

作为我写书时研究的一部分，我在 Redis 的网站上看见了一个叫做 RedLock 的算法。这个算法声称在 Redis 上实现了容错的分布式锁，网站上的页面也邀请从事分布式系统的的人给出反馈。这个算法本能地触发了我脑海里的警钟，所以我花了一点时间思考它和写下这些提醒。



因为已经有超过 10 个独立的 Redlock 实现，我们也不知道谁已经依赖这个算法，所以我认为公开分享我的提醒是有价值的。我不会提及 Redis 的在其他地方已经被批判过的方面。



在我深入 Redlock 之前，让我说清楚，我十分地喜欢 Redis，并且在过去我成功的把它用在生产环境中。我认为存储一些服务器之间的短暂的、近似的、快速改变的数据的场景很适合 Redis，并且无论什么原因偶尔丢失一些数据不是很重要。比如，一个好的场景是维护每个 IP 地址的请求数（用于限制速率目的）和每个 user ID 的 IP 地址集合（用于滥用监测）。



然而，Redis 已经慢慢的向数据管理 (data management) 领域发展，这个领域要求强一致性和持久性——也正是让我担心的地方，因为这不是 Redis 设计的目的。可证明的是，分布式锁是这些领域里的一个。让我们从更细的方面讨论。



## 你使用锁的用途是什么？

使用锁的目的是确保在数个做相同工作的节点中仅有一个节点（至少在某一时刻只有一个）在做。这种工作可能是向一个共享存储系统中写一些数据，或是执行一些计算，或是调用一个外部 API 等。从高层次上说，有俩个你想要在分布式应用中使用锁原因，1个是效率，1个是正确性。要区分开这俩个原因，可以看如果锁失败时发生了什么：

- 效率：使用一个锁可以让你避免不必要地重复执行两次相同的工作。如果锁失败，两个节点做了同样的工作，则结果是成本略有增加（需要向 AWS 多付5美分）或者带来一些不便（比如一个用户得到2次相同的 email 提醒）。
- 正确性：使用一个锁防止并发的进程踩到对方的脚，混淆你系统的状态。如果锁失败，两个节点同时在同一份数据上工作，则结果是得到一份损坏的文件，数据丢失，永久的不一致性，给患者开了错误剂量的药或者其他一些严重的问题。

上面两种都是想要锁的有效场景，但是你需要弄清楚哪一种是你要处理的。



我认为，如果你使用锁仅仅是为了效率的目的，没有必要运行 5 个 Redis 服务节点并检查大多数的节点来获得锁招致 Redlock 的代价和复杂性。你最好使用一个 Redis 节点，可能有异步副本到第二个节点上，防止主节点崩溃。



如果你使用单个 Redis 实例，当然你会丢失一些锁在 Redis 节点电源突然断开的情况下，或者其他的什么出了错。但是，如果你仅仅使用锁作为一个效率优化，并且崩溃不会经常发生，这也没什么问题。这个 "没什么问题" 的场景就是 Redis 的发光点。至少，如果你依赖单个 Redis 实例，锁是近似的对每个看到系统的人都很清楚，并且仅仅被用于非关键的目标。



在另一方面，Redlock 算法有 5 个副本和多数投票，第一眼看上去好像你的使用这个锁保证正确性合适的。我下接下来的章节中会争论到，它对这个场景不适合。在接下来的这篇文章里，我将会假设你的锁对于正确性很重要，并且如果两个不同的节点同时地认为自己拿到了同一个锁是一个严重的缺陷。



## 用锁来保护资源

我们先不说 Redlock，讨论下大体上是怎么用分布式锁的（独立于具体的锁算法实现）。记住分布式锁和多线程的互斥量不同是很重要的。分布式锁是更复杂的野兽，这要归功于不同的节点和网络能以各种方式独立的出现故障。



举个例子，假如你有个客户端需要更新共享存储里的文件的应用。一个客户端首先获得了锁，然后读文件，做一些修改，写入文件，最后释放锁。这个锁阻止了2个客户端同时地读-修改-写文件。代码看起来像这样：

```c
// THIS CODE IS BROKEN
function writeData(filename, data) {
    var lock = lockService.acquireLock(filename);
    if (!lock) {
        throw 'Failed to acquire lock';
    }

    try {
        var file = storage.readFile(filename);
        var updated = updateContents(file, data);
        storage.writeFile(filename, updated);
    } finally {
        lock.release();
    }
}
```

不幸的是，即使你有一个完美的锁服务，上面的代码还是有问题的。下面的图展现了你是如何得到一个损坏了的文件的。

![unsafe-lock](./unsafe-lock.png)

在此示例中，获取锁的客户端1在持有锁的同时暂停了一段较长的时间，比如可能是垃圾回收器插入了进来。锁服务有个超时时间是个很不错的考虑（否则一个崩溃的客户端可能会一直持有锁，永远不会释放锁）。然而，如果 GC 导致的暂停比锁的超时时间要长，并且客户端没有意识到已经超出了锁的有效期，它会继续往下走造成一些不安全的更改。



这个缺陷不是理论上的：HBase 过去常常有这个问题。通常，GC 的暂停非常短，但是 "stop-the-world" GC 暂停有时已知会持续几分钟时长——足以让锁超时。即使称为并发的垃圾回收器，像 HotSpot JVM 的 CMS，也不能完全地和应用代码并行运行——即使他们需要不时的停止运转。



在往存储里写之前检查锁是否超时并不能修复这个问题。记住，GC 能在任何地方让一个线程暂停，包括给你带来很大不便的地方（在最后一次检查和写操作之间）。



如果你因为你的编程语言没有长期的 GC 暂停感到庆幸时，还有很多其他原因造成你的进程停顿。有可能是你的进程尝试去读一个地址，这个地址目前还没有被加载到内存中，所以它会遇到页错误并暂停直到页被加载。也许你的磁盘是 EBS，所以读取变量会不经意间转变为通过 Amazon 拥塞网络发出的同步网络请求。也许还有许多其他争用 CPU 的进程，而你在调度程序树中遇到了一个黑色节点。也许某人偶然发了 SIGSTOP 信号给进程。总之，你的进程会停顿。



如果你仍然不相信进程会停顿，那在考虑请求文件写操作可能会到达存储服务前在网络中被延迟。以太网和 IP 可能会任意的延迟包，比如：在 github 上发生的著名事故，网络中的包被延迟约 90 秒。这表明，一个应用进程发送一个写请求，这个请求在一分钟之后到达存储服务，而锁早已超时。

即使在管理得当的网络中，这种事情也是经常发生。您根本无法对时间做出任何假设，这就是无论您使用哪种锁定服务，上述代码从根本上来说都是不安全的。



## 用围栏让锁变得安全

这个问题的修复方法实际上很简单：每次向存储服务写时需要带一个围栏令牌（fencing token）。在此处，一个围栏令牌就是一个简单的数字，这个数字在每次客户端获取到锁时都会增加（由 lock service 负责增加）。像下图表示一样：![fencing-tokens](./fencing-tokens.png)

客户端1取得了锁，并同时得到一个令牌 33，之后它进入了长暂停时期，然后锁超时。客户端2随后获得了锁，同时得到令牌 34（数字一直增加），随后带上令牌 34 向存储发送写操作。之后，客户端1从长暂停中恢复，带着令牌 33 向存储发送写操作。然而，存储服务记得它已经执行了一个令牌数字更高（34）的写请求，所以它拒绝了令牌数字 33 的写请求。



注意，这要求存储服务扮演一个令牌检查的角色，拒绝任何低令牌数字的写请求。不过这并不是很难，只要你知道其中的窍门。规定锁服务产生严格单调递增的令牌，这就让锁变得安全。例如，使用 ZooKeeper 作为锁服务，你可以使用 zxid 或者 znode 版本号作为围栏令牌，你就处于好的形态中了。



然而，这把我们引向 Redlock 的第一个大问题：它没有任何产生围栏令牌的措施。此算法没有产生在客户端获得锁时递增的任何数字。这意味着，即使此算法在其他方面是完美的，也无法安全使用，因为无法阻止多个客户端中有个客户端被停顿或数据包被延迟的场景下的数据竞争。



对我来说，还不知道如何更改 Redlock 算法来产生一个围栏令牌。他使用的唯一的随机值不能提供所需的单调性。在一个 Redis 节点上保留一个计数器是不够的，因为它可能会故障。在多个节点上保留计数器，意味着它们可能不同步。这意味着需要一个一致算法才能生成围栏令牌（仅仅一个增长的计数器简单了）。



## 使用时间来解决一致性

在依赖锁获得正确性场景下，Redlock 未能生成围栏令牌的事实已经是足够的理由不使用它了。还有其他更深的问题值得讨论。



在学术文献里，这种算法的最实用的系统模型是  asynchronous model with unreliable failure detectors，通俗地解释就是，算法不应该有任何关于时间的假设；进程也许停任意时长，网络里的包也许被延时任意时长，时钟可能如原无故地出错——但是算法还是被期望被假设做正确的事情。通过我们上面的讨论，这些是非常合理的假设。



算法可能使用时钟仅仅是用于产生超时时间的目的，避免永远等待一个已经下线的节点。但是超时时间不是非得精确的：仅仅凭借一次请求超时，不能表示其他节点肯定下线了，它仅仅可能是因为在网络中有一个大延迟或者你本地的时钟出现了问题。当把算法作为故障检测器时，超时仅是某些错误的猜测。（如果它们可以的话，分布式算法可以不使用时钟，但就不能保证一致性的问题，获取锁就像是比较和设置操作，它们是要求一致性的）



Redis 里使用 gettimeofday 来判断 keys 是否过期，但它不是一个单调的时钟。gettimeofday 的首页明显的写到，它返回的时间受系统时间的不连续跳跃影响；也就是说，它可能突然向前跳了几分钟，甚至往回跳了（比如，如果时钟和 NTP 相差很大，NTP 把系统时钟往前调了，或者时钟由系统管理员调整了）。因此，如果系统时钟做了一些奇怪事情，Redis 里很容易发生 key 的提前或推迟超时。



在 asynchronous model with unreliable failure detectors 里的算法就不会有这个问题，这些算法保证，没有任何关于时间的假设，它们的安全属性也能保持住。只有 "活性" 相关的属性会依赖到超时或者其他的故障检测。用通俗地解释，即使系统定时到处都有（进程暂停，网络延迟，时钟来回跳跃），算法的性能可能变得非常差，但是算法永远不会做出错误的决定。



然而，Redlock 和这个并不一样。它的安全取决于很多时间上的假设：假设所有 Redis 节点在过期前持有近似的正确的时间长度；假设网络延迟和超时时间比起来很小，假设进程停顿和超时时间比起来很小。



## 用时间攻破 Redlock

让我们来看几个证明 Redlock 依赖时间假设的例子。



假设系统有 5 个 Redis 节点（A，B，C，D 和 E），有两个客户端（1 和 2），假如 Redis 节点中的一个节点时钟前进了几分钟会发生什么？

1. 客户端 1 获取 A、B、C 节点上的锁，由于网络上的原因，D、E 节点不可达。
2. C 节点的时钟前进了几分钟，导致锁超时。
3. 客户端 2 获取 C、D、E 节点上的锁，由于网络原因 A、B 不可达。
4. 客户端 1 和客户端 2 认为自己持有了锁。

如果节点 C 在把锁持久化到硬盘前崩溃了，并立即重启，也会出现相似的情况。为此，Redlock 文档建议推迟启动崩溃的节点，至少推迟和生存时间最久的锁的 TTL 时长一样。但是重启又依赖合理的、精确的时间测量，当在时钟跳跃时也会失败。



当你正确地配置了 NTP 来调整时钟时，你也许认为不会发生时钟跳跃的现象。在这种场景下，我们看一个例子，一个进程暂停导致算法故障的例子。

1. 客户端 1 请求锁定 A、B、C、D、E 节点。
2. 当客户端 1 的请求返回值正在路上，客户端 1 进入 stop-the-world gc。
3. Redis 节点上的锁全部超时。
4. 客户端 2 请求锁定 A、B、C、D、E 节点。
5. 客户端 1 完成 GC，并且收到了来自 Redis 节点的返回值，此返回值表明成功地获得了锁（当进程被延误时，返回值被保存在客户端 1 的内核网络缓冲区里）。
6. 客户端 1 和客户端 2 都认为自己现在拿到了锁。

即使 Redis 是用 C 语言写的，没有 GC，但是在此处帮不到我们：任何一个系统里，如果客户端含有 GC 暂停，都会遇到这个问题。想要让系统变得安全，只能阻止客户端 1 执行任何其他操作直到客户端 2 获得锁，比如使用上面提到的围栏令牌方法。



一个长时间的网络延迟也可以产生和进程暂停相同影响的效果。它可能取决于你的 TCP 超时时间——假如你配置网络超时时间明显的短于 Redis TTL，可能延迟的网络包裹将会被忽略掉，但是我们需要详细看一下 TCP 的实现才能确定。此外，随着超时，我们又回到了时间测量的准确性！



## Redlock 同步锁的假设

上面的例子证明了 Redlock 在同步的系统模型里能正常工作的。这个同步的系统要有下面属性：

- 有限的网络延迟（网络上的包在保证的时间内到达）。
- 有限的进程暂停（很严格的实时限制，通常在汽车安全气囊系统才能找到）。
- 有限的时钟错误（你不能从不良的 NTP 服务器获取时间）。

注意同步模型不意味着严格的同步时钟：它意味着你知道网络延迟的上限，停顿和时钟漂移。Redlock 假设延迟、停顿、漂移对于锁的 Time-to-live 时间比起来很小；如果时间变得比锁的 Time-to-live 大，算法会变得故障。



在一个表现良好的数据中心里，关于时间的假设大多数情况下都是满足的——这也被大家了解的部分同步系统。但是这样就行了吗？只要关于时间的假设不成立了，Redlock 就破坏了它的安全属性，比如，授权一个锁给另一个客户端在当前客户端锁没有过期前。如果你依赖锁保持正确性，"大多数时间是正确的" 并不足够，你需要永远保持正确。



有大量的证据表明在实用的系统环境中使用同步系统是不安全的，时刻记住你在 github 上有 90s 网络延迟的事情。Redlock 不太可能通过 Jepsen 测试。



在另一方面，给部分同步体统设计的一致性算法模型实际上是有起效的机会的。Raft, Viewstamped Replication, Zab 和 Paxos  都属于此类算法，此类算法必须有关于时间的假设。这是很难的，它也冒着假设网络、进程、时钟都比它们真实情况下还可靠的风险。但是在大量的现实使用的分布式系统中，你需要对你的假设变得很小心。



## 总结

我认为 Redlock 算法不是一个好的选择，因为它不伦不类：对于使用锁来优化效率的目的，它被设计的过于重量级和高代价，对于使用锁来保证正确性的目的，它又不是足够的安全。



特别是这个算法在时间和系统时钟上做了一个危险的假设（假设同步系统基于有限的网络延迟和受限的时间操作），如果这个假设不成立是它的安全性就收到了破坏。更多的是，它缺少产生围栏令牌功能（围栏令牌的功能是保护系统免于收到长网络延时和进程暂停的影响）。



如果你使用锁的目的是效率目的（提升效率，不是保证正确性的目的），我会推荐使用 Redis 的  [straightforward single-node locking algorithm](http://redis.io/commands/set) 算法（如果不存在条件下获取锁，如果值不存在情况下通过原子来释放锁），并且在代码里注释清楚，此锁仅是近似准确可能偶尔会失败。不用麻烦的设置一个 5 个节点的 Redis 集群。



在另一方面，如果你用锁来保持正确性，请不要使用 Redis，使用一个合适的一致性系统，如 ZooKeeper，它可能通过一个 Curator 副本实现锁（至少也使用数据库的事务来保证）。并且确保在使用锁获取资源时带上围栏令牌。



像我和开头说的一样，如果你正确地使用了 Redis 它是一个杰出的工具。以上所有内容都不会削弱把 Redis 用于其预期目的的有用性。 [Salvatore](http://antirez.com/) 多年来致力于这个项目的发展，其成功理所当然。但是每种工具都有局限性，了解他们并合理计划很重要。



如果你想知道的更多的话，我在我的书第 8 和 9 章详细的介绍了这章，目前 O'Reilly 的早期发行版本已经可以获取了。对于如何使用 ZooKeeper  我推荐  [Junqueira and Reed’s book](http://shop.oreilly.com/product/0636920028901.do) ，对于分布式系统的入门理论介绍我推荐 [Cachin, Guerraoui and Rodrigues’ textbook](http://www.distributedprogramming.net/)  。



##### 翻译后记

在翻译的过程中也能获得乐趣！！！哈哈哈！！！		——2020.01.11